<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Server-side probabistic programming</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/arduino-light.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Server-side probabilistic programming</h1>
          <p><emph>David Tolpin, <a href="http://publus.com/">PUB+</a></emph></p>
        </section>
        <section>
          <section>
            <h2>Challenges</h2>
          </section>
          <section>
            <h3>Simulation vs. inference</h3>
          </section>
          <section>
            <h3>Data interface</h3>
          </section>
          <section>
            <h3>Deployment</h3>
          </section>
        </section>
        <section>
          <section>
            <h2>Guidelines</h2>
          </section>
          <section>
            <h3>One language</h3>
          </section>
          <section>
            <h3>Shared data structures</h3>
          </section>
          <section>
            <h3>Inference code re-used in simulation</h3>
          </section>
        </section>
        <section>
          <section>
            <h2>Probabilistic programming<br/>in Go</h2>
          </section>
          <section>
            <h3>'hello world': model</h3>
            <pre><code class="go" data-trim data-noescape>
 1  type Model struct {
 2      Data []float64
 3  }
 4  
 5  // x[0] is the mean, x[1] is the 
 6  // log stddev of the distribution
 7  func (m *Model) Observe(x []float64) float64 {
 8    // Our prior is a unit normal ...
 9    ll := Normal.Logps(0, 1, x...)
10    // ... but the posterior is based on data observations.
11    ll += Normal.Logps(x[0], math.Exp(x[1]), m.Data...)
12    return ll
13  }
            </code></pre>
          </section>
          <section>
            <h3>'hello world': data
            <pre><code class="go" data-trim data-noescape>
 1  m := &Model{[]float64{
 2    -0.854, 1.067, -1.220, 0.818, -0.749,
 3    0.805, 1.443, 1.069, 1.426, 0.308}}
            </code></pre>

          </section>
          <section>
            <h3>'hello world': optimization</h3>
            <pre><code class="go" data-trim data-noescape>
 1  x := []float64{0, 0}
 2    
 3  opt := &infer.Momentum{
 4    Rate:  0.01,
 5    Decay: 0.998,
 6  }
 7  for iter := 0; iter != 1000; iter++ {
 8    opt.Step(m, x)
 9  }
10  mean, logs = x[0], x[1]
            </code></pre>
          </section>
          <section>
            <h3>'hello world': posterior</h3>
            <pre><code class="go" data-trim data-noescape>
 1  x := []float64{0, 0}
 2    
 3  hmc := &infer.HMC{
 4    Eps: 0.1,
 5  }
 6  samples := make(chan []float64)
 7  hmc.Sample(m, x, samples)
 8  for i := 0; i != 1000; i++ {
 9    x = <-samples
10  }
11  hmc.Stop()
            </code></pre>
          </section>
          <section>
            <h3>'hello world': streaming</h3>
            <pre><code class="go" data-trim data-noescape>
 1  type Model struct {
 2    Data chan float64  // data is a channel
 3    N    int           // batch size
 4  }
 5  
 6  func (m *Model) Observe(x []float64) float64 {
 7    ll := Normal.Logps(0, 1, x...)
 8    // observe a batch of data from the channel
 9    for i := 0; i != m.N; i++ {
10      ll += Normal.Logp(x[0], math.Exp(x[1]), <- m.Data)
11    }
12    return ll
13  }
            </code></pre>
          </section>
					<section>
						<h3>Why Go?</h3>
						<ul>
							<li>Comes with parser and type checker.</li>
							<li>Compiles and runs fast.</li>
							<li>Allows efficient parallel execution, via
								<i>goroutines</i>.</li>
						</ul>
					</section>
        </section>
        <section>
          <section>
            <h2>Infergo</h2>
          </section>
          <section>
            <h3>Model</h3>
						Model interface:
            <pre><code class="go" data-trim data-noescape>
1 type Model interface {
2   Observe(parameters []float64) float64
3 }
            </code></pre>
						<div class="fragment">
						A model (exponential distribution):
            <pre><code class="go" data-trim data-noescape>
1 type Model float64 
2 
3 func (m Model) Observe(x []float64) float64 {
4   return -x*m
5 }
            </code></pre>
						</div>
          </section>
          <section>
            <h3>Distributions</h3>
						A distribution is a model:
            <pre><code class="go" data-trim data-noescape>
 1  var Normal normal
 2
 3  // Observe implements the Model interface.
 4  func (dist normal) Observe(x []float64) float64 {
 5    mu, sigma, y := x[0], x[1], x[2:]
 6    return dist.Logps(mu, sigma, y...)
 7  }
            </code></pre>
          </section>
          <section>
            <h3>Distributions (cont.)</h3>
            <pre><code class="go" data-trim data-noescape>
 8  // Logp computes the log pdf of a single observation.
 9  func (_ normal) Logp(mu, sigma float64, y float64)
10      float64 {
11    ...
12  }
13
14  // Logps computes the log pdf of a vector of observations.
15  func (_ normal) Logps(mu, sigma float64, y ...float64)
16      float64 {
17    ...
18  }
				</code></pre>
          </section>
          <section>
            <h3>Differentiation</h3>
						<ul>
							<li>All methods on the type implementing <code>model.Model</code>
								are differentiated.</li>
							<li>Within the methods, the following is differentiated:
								<ul>
									<li>assignments to <code>float64</code>;</li>
									<li>returns of <code>float64</code>;</li>
									<li>standalone calls to methods on the type implementing model.Model.</li></ul></li>
						</ul>
          </section>
					<section>
						<h3>Differentiation (cont.)</h3>
						Reverse-mode via source code transformation:
						<pre style="font-size: 60%"><code class="go" data-trim data-noescape>
 1  func (m *Model) Observe(x []float64) float64 {
 2    var ll float64
 3    ad.Assignment(&ll, ad.Call(func(_ []float64) {
 4      Normal.Logps(0, 0, x...)
 5    }, 2, ad.Value(0), ad.Value(1)))
 6    ad.Assignment(&ll, 
 7      ad.Arithmetic(ad.OpAdd, &ll,
 8        ad.Call(func(_ []float64) {
 9          Normal.Logps(0, 0, m.Data...)
10        }, 2, &x[0], ad.Elemental(math.Exp, &x[1]))))
11    return ad.Return(&ll)
12  }
						</code></pre>
					</section>
          <section>
            <h3>Inference</h3>
						<ul>
							<li>Optimization via gradient ascent (Momentum,
								Adam), works with streamed and stochastic
								data.</li>
							<li>Full posterior inference via HMC variants.
								Samples are produced concurrently and passed
								through a channel.</li>
						</ul>
          </section>
        </section>
        <section>
          <section>
            <h2>Examples</h2>
						<ul>
							<li>Simple models are still simple.</li>
							<li>Complex models are less complex.</li>
						</ul>
						<p>
						More <a href="http://infergo.org/examples"><code>infergo</code> examples...</a>
						</p>
          </section>
          <section>
						<h3>8 schools</h3>
						<table width="100%">
							<tr><th width="40%">Stan</th><th width="60%"><code>infergo</code></th></tr>
							<tr style="font-size: 70%">
								<td>
								<pre><code class="go" data-trim data-noescape>
data {
  int&lt;lower=0&gt; J;
  vector[J] y;
  vector&lt;lower=0&gt;[J] sigma;
}

parameters {
  real mu;
  real&lt;lower=0&gt; tau;
  vector[J] eta;
}

transformed parameters {
  vector[J] theta;
  theta = mu + tau * eta;
}

model {
  eta ~ normal(0, 1);
  y ~ normal(theta, sigma);
}

            </code></pre>
                </td><td>
            <pre><code class="go" data-trim data-noescape>
type Model struct {
  J          int
  Y          []float64
  Sigma      []float64
}

func (m *Model) Observe(x []float64) float64 {
  mu := x[0]
  tau := math.Exp(x[1])
  eta := x[2:]

  ll := Normal.Logp(0, 1, eta)
  for i, y := range m.Y {
    theta := mu + tau*eta[i]
    ll += Normal.Logp(theta, m.Sigma[i], y)
  }
  return ll
}
            </code></pre>
								</td></tr></table>
          </section>
          <section>
            <h3>Gaussian mixture</h3>
						<table width="110%">
							<tr style="font-size: 65%"><td width="50%">
            <pre><code class="go" data-trim data-noescape>
type Model struct {
  Data  []float64 // samples
  NComp int       // number of components
}

func (m *Model) Observe(x []float64) float64 {
  ll := 0.0
  mu := make([]float64, m.NComp)
  sigma := make([]float64, m.NComp)

  // Fetch component parameters
  for j := 0; j != m.NComp; j++ {
    mu[j] = x[2*j]
    sigma[j] = math.Exp(x[2*j+1])
  }
...

            </code></pre>
                </td><td width="50">
            <pre><code class="go" data-trim data-noescape>
...
  // Compute log likelihood of mixture given the data
  for i := 0; i != len(m.Data); i++ {
    var l float64
    for j := 0; j != m.NComp; j++ {
      lj := Normal.Logp(mu[j], sigma[j], m.Data[i])
      if j == 0 {
        l = lj
      } else {
        l = mathx.LogSumExp(l, lj)
      }
    }
    ll += l
  }
  return ll
}
            </code></pre>
								</td></tr></table>
          </section>
        </section>
        <section>
          <h2>Acknowledgements</h2>
          <ul>
            <li><a href="https://www.cs.ubc.ca/~fwood/">Frank Wood</a> introduced me to
              probabilistic programming.</li>
            <li><a href="http://www.ccs.neu.edu/home/jwvdm/">Jan-Willem van de Meent</a>
discussed with me motives, ideas, and implementation
choices behind <code>infergo</code>.</li>
            <li><a href="http://pubplus.com/">PUB+</a> supported me in
              development of <code>infergo<code>.</li>
          </ul>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
          transition: 'fade',
          math: {
              mathjax: 'MathJax/MathJax.js',
              config: 'TeX-AMS_HTML-full'
          },
          dependencies: [
              { src: 'plugin/markdown/marked.js' },
              { src: 'plugin/markdown/markdown.js' },
              { src: 'plugin/notes/notes.js', async: true },
              { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: 'plugin/math/math.js', async: true }
          ]
      });
    </script>
  </body>
</html>

\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
\usepackage{url}
\usepackage{hyperref}

\acmConference[LAFI'2019]{Languages for Inference}{January 15,
2019}{Lisbon, Portugal}

\setcopyright{none}

\bibliographystyle{ACM-Reference-Format}

\begin{abstract}
We present a view on practical probabilistic programming, as
well as an inference facility for Go programs following the
view. Probabilistic programming promises to free the
practitioner from burden of re-implementing inference paradigms
and algorithms. There are dozens of probabilistic programming
languages currently in development. Yet, integrating
probabilistic programming inference into a software system
requires greater effort than writing a custom simulation and
inference algorithm. Probabilistic programming remains, at best,
a tool for modeling and prototyping.

We believe that the probabilistic programming approach can be
made practical. However, this requires a shift from design of
languages best suited for probabilistic inference to design of
tools and libraries which make probabilistic programming in
modern general-purpose languages accessible and convenient.
Here, we first discuss the challenges in practical use of
existing probabilistic programming systems, and then suggest 
guidelines to implementation of a practical probabilistic
programming facility. We illustrate the guidelines on an
early-stage implementation of such facility for the Go
programming language. 
\end{abstract}


\begin{document}

\title{Towards Practical Probabilistic Programming}
\author{David Tolpin}
\affiliation{
    \institution{PUB+}
    \country{Israel}
}
\email{david.tolpin@gmail.com}


\maketitle

\section{Challenges in Practice of Probabilistic Programming}

Incorporating a probabilistic program, or rather a probabilistic
procedure, within a larger code body appears to be rather
straightforward: one implements the model in the probabilistic
language, fetches and preprocesses the data in the
`regular' host programming language, passes the data and the
model to an inference algorithm, and post-processes the results
in the `regular' programming language again to make algorithmic
decisions based on inference outcomes. The reality is more
complicated though, and the practitioner may face obstacles on
each step of the above routine.

\paragraph{Implementing the model} Probabilistic programming is
supposed to let the programmer use the expressive power of a
general programming language to specify probabilistic models.
However, the probabilistic language is often either a small
language lacking advanced control and data manipulation
capabilities (Anglican~\cite{TMY+16}, Stan~\cite{Stan17},
WebPPL~\cite{GS15}), or an API to the representation of the
probabilistic model (Edward~\cite{THS+17}, Figaro~\cite{P09}).
When the probabilistic language is the same or as rich as the
host language, its use is still constrained by available data
structures (Pyro~\cite{Pyro18}), or, the host language is 
uncommon as a general-purpose language (Turing~\cite{GXG18}).
Often, the probabilistic language is interpreted, making
execution of the model too slow.

\paragraph{Passing the data} The case when all observations are
handed over to inference in bulk, and a short summary of
inference results returned, can mostly be implemented
efficiently. This use case is well addressed by most
environments even when the host language differs from the
probabilistic language. A difficulty arises when
the data arrives incrementally, and inference outcomes are
processed in any-time manner. Data has to be marshalled when the
host and probabilistic language platforms differ (e.g.
Stan), or transferred between data structures used in
the host language and the data structures required by the
probabilistic language (e.g. Pyro).

\paragraph{Simulation-inference dichotomy} Many probabilistic
models follow a design pattern of simulation-inference: a
significant part of the model is a simulator, running an
algorithm with fixed parameter; the optimal parameters, or their
distribution, are to be inferred. The simulator may be quite
complicated, however in addition to the apparent difficulty of
implementing the simulator in a less expressive language,  the
simulator has to be implemented twice: first in the
probabilistic language for inference, and then in the host
environment to make use of the inferred parameters. This not
just involves extra effort but is also prone to introducing
programming mistakes, when the two versions of the simulator
behave differently for the same parameter values. One possible
solution is to treat the simulator as a black box~\cite{LBW17},
however better inference algorithms can be used if the structure
of the simulator is revealed to the probabilistic programming
facility, e.g. through the use of automatic differentiation.

\paragraph{Deployment} A software system composed of
heterogeneous languages and environments is harder to integrate
and deploy. Many software solutions are monolithic, comprising
of just a single programming language and with a conservative
set of dependencies. Adding a probabilistic programming system,
often depending on a different runtime and libraries, makes
integration and deployment more complicated.

\section{Guidelines to a Practical Probabilistic Programming
Facility}

Based on the experience of implementing  probabilistic
programming languages, as well as developing and deploying
solutions using different probabilistic environments, we suggest
guidelines to implementation of a probabilistic programming
facility. We believe that these guidelines, if followed, will
lead to eventual wide adoption of probabilistic programming in
software engineering.

\begin{enumerate}
\item A probabilistic model should be programmed in the host
programming language. The facility may impose a discipline on
model implementation, such as through interface constraints, but
otherwise supporting unrestricted use of the host language for
implementation of the model.

\item Built-in and user-defined data structures and libraries
should be accessible in the probabilistic programming model.
Inference techniques relying on the code structure, such as
those based on automatic differentiation, should support the
use of common data structures of the host language.

\item The model code should be reusable between inference and
simulation. The code which is not required solely for inference
should be written once for both inference of parameters and use
of the parameters in the host environment.  It should be
possible to run simulation outside the probabilistic model without
runtime or memory overhead imposed by inference needs.
\end{enumerate}

\section{Probabilistic Programming Facility for
Go}

Following the guidelines, we have implemented a probabilistic
programming facility for the Go programming language,
\texttt{infergo} (\url{http://infergo.ml/}). We have chosen Go
because Go is a relatively small programming language with
efficient implementation, which has recently become quite
popular for computation-intensive server-side programming. At
the time of writing, the implementation is still at an early
stage. However, this facility is already used in production
environment for inference of mission-critical algorithm
parameters.  

A probabilistic model in \texttt{infergo} is an implementation
of the \texttt{Model} interface requiring a single method
\texttt{Observe} which accepts a vector (a Go \textit{slice}) of
floats, the parameters to infer, and returns a single float,
interpreted as unnormalized log-likelihood of the posterior
distribution. The implementation of the methods can be written
in virtually unrestricted Go and use any Go libraries.

For inference, \texttt{infergo} relies on automatic
differentiation. The source code of the model is
translated by a command-line tool provided by \texttt{infergo}
into an equivalent model with reverse-mode automatic
differentiation of the log-likelihood with respect 
to the parameters applied. The differentiation operates
on the built-in floating-point type and incurs only a small
computational overhead. However, even this overhead is avoided
when the model code is executed outside of inference algorithms:
both the original and the differentiated model are
simultaneously available to the rest of the program code, so
the methods can be called on the differentiated model for
inference, and on the original model for the most efficient
execution with the inferred parameters.

While we enjoy the ease and efficiency of \texttt{infergo}-based
inference in our production environment, we view
\texttt{infergo} as a reference implementation rather than as
the only recommended solution, and encourage the community to
equip other general-purpose languages with similar inference
facilities, which, we believe, will make wide adoption of
probabilistic programming more likely.

\bibliography{refs}

\end{document}
